import{_ as i,p as c,s as d,D as o,I as a,v as e,L as t,S as s,q as h}from"./chunks/framework.3f494197.js";const le=JSON.parse('{"title":"指令系統","description":"","frontmatter":{},"headers":[],"relativePath":"zh-TW/manual/usage/command.md","filePath":"zh-TW/manual/usage/command.md"}'),_={name:"zh-TW/manual/usage/command.md"},p=e("h1",{id:"指令系統",tabindex:"-1"},[t("指令系統 "),e("a",{class:"header-anchor",href:"#指令系統","aria-label":'Permalink to "指令系統"'},"​")],-1),r=e("p",null,"在瞭解了控制檯的基本用法後，我們終於可以開始介紹如何與機器人對話了！讓我們從上一節中看到的例子開始：",-1),u=e("p",null,"當前可用的指令有：",-1),m=e("p",{class:"indent-1"},"echo 傳送訊息",-1),k=e("p",{class:"indent-1"},"help 顯示幫助資訊",-1),f=e("p",null,"輸入“幫助 指令名”檢視特定指令的語法和使用示例。",-1),g=s('<p>這裡的輸出與兩個外掛有關：</p><ul><li>help 指令由 <a href="./../../plugins/common/help.html">help</a> 外掛提供，它可以顯示指令列表或具體指令的幫助資訊</li><li>echo 指令由 <a href="./../../plugins/common/echo.html">echo</a> 外掛提供，它可以將使用者的輸入原樣返回</li></ul><p>一個 Koishi 機器人的絕大部分功能都是透過指令提供給使用者的。當你安裝了更多的外掛後，你也就有了更多的指令可供使用。</p><h2 id="檢視幫助" tabindex="-1">檢視幫助 <a class="header-anchor" href="#檢視幫助" aria-label="Permalink to &quot;檢視幫助&quot;">​</a></h2><p>help 指令後還可以新增一個引數，用於檢視特定指令的幫助資訊：</p>',5),T=e("p",null,"指令：echo <message...>",-1),x=e("p",null,"傳送訊息",-1),A=e("p",null,"可用的選項有：",-1),b=e("p",{class:"indent-1"},"-e, --escape 傳送轉義訊息",-1),v=e("p",{class:"indent-1"},"-E, --unescape 傳送反轉義訊息",-1),P=e("p",null,"那麼細心的小夥伴可能會發現，既然 help 本身也是一個指令，那我能不能用來檢視 help 自己的幫助資訊呢？答案是肯定的：",-1),y=e("p",null,"指令：help [command]",-1),S=e("p",null,"顯示幫助資訊",-1),q=e("p",null,"可用的選項有：",-1),K=e("p",{class:"indent-1"},"-a, --authority 顯示許可權設定",-1),C=e("p",{class:"indent-1"},"-H, --show-hidden 檢視隱藏的選項和指令",-1),V=s('<h2 id="引數和選項" tabindex="-1">引數和選項 <a class="header-anchor" href="#引數和選項" aria-label="Permalink to &quot;引數和選項&quot;">​</a></h2><p>在上面的用法中，我們接觸到了兩個新的概念：<strong>引數 (Argument)</strong> 和 <strong>選項 (Option)</strong>。</p><p>引數分為必選引數和可選引數，分別用尖括號 <code>&lt;&gt;</code> 和方括號 <code>[]</code> 表示。一個指令可以有任意多個引數，它們的順序是固定的，使用者必須按照指令定義的順序來輸入引數。必選引數一定出現在可選引數之前。如果使用者輸入的引數數量不足必選引數的個數，那麼外掛通常會給出錯誤提示；如果使用者輸入了額外的引數，那麼會被忽略。</p><p>例如，help 指令共有一個引數，它是可選引數，表示要檢視的指令名；echo 指令也有一個引數，它是必選引數，表示要傳送的訊息。讓我們看看如果不填必選引數會怎麼樣：</p>',4),I=e("p",null,"請輸入要傳送的文字。",-1),E=e("p",null,[t("選項同樣可以控制指令的行為。它通常以 "),e("code",null,"-"),t(" 或 "),e("code",null,"--"),t(" 開頭，後面不帶空格地跟著一個固定的單詞，稱為選項名稱。選項之間沒有順序要求，但通常建議將選項放在引數之前。讓我們試試看：")],-1),N=e("img",{src:"https://koishi.chat/logo.png",width:"100"},null,-1),z=e("p",null,[t("在上面的例子中，我們使用了 "),e("code",null,"-E"),t(" 選項，成功改變了輸出的內容。關於這具體是怎麼做到的，我們會在後續的章節中進行介紹。")],-1),D=e("p",null,[t("引數除了可以分為必選和可選外，還可以分為定長和變長。定長引數的中不能出現空白字元，而變長引數則可以。變長引數透過引數名前後的 "),e("code",null,"..."),t(" 來指示，例如 "),e("code",null,"echo"),t(" 指令的引數就是一個變長引數。如果要為定長引數傳入帶有空白字元的內容，可以使用引號將其包裹起來，例如：")],-1),R=e("p",null,"此外，部分選項也可以接受引數。例如，當你安裝了翻譯外掛，你將會獲得如下的幫助資訊：",-1),$=e("p",null,"指令：translate <text...>",-1),w=e("p",null,"文本翻譯",-1),B=e("p",null,"可用的選項有：",-1),W=e("p",{class:"indent-1"},"-s, --source <lang> 源語言 (預設為自動匹配)",-1),j=e("p",{class:"indent-1"},"-t, --target <lang> 目標語言 (預設為中文)",-1),G=s(`<p>在這個例子中，<code>-s</code> 和 <code>-t</code> 都是帶有引數的選項。我們使用 <code>-t ja</code> 來指定目標語言為日語，源語言仍然採用了預設行為。</p><h2 id="觸發字首" tabindex="-1">觸發字首 <a class="header-anchor" href="#觸發字首" aria-label="Permalink to &quot;觸發字首&quot;">​</a></h2><p>然而，如果僅僅透過一個詞就能觸發指令，在群聊環境下非常容易出現誤觸。為了避免這種情況，Koishi 引入了字首觸發的概念。在「全域性設定」中，我們提供了名為 <code>prefix</code> 和 <code>nickname</code> 的配置項。假如將 <code>prefix</code> 設定為 <code>/</code>，<code>nickname</code> 設定為 <code>四季醬</code>，則在群聊環境下只有以下資訊可以觸發指令呼叫：</p><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre><code><span class="line"><span style="color:var(--shiki-token-function);">四季醬,</span><span style="color:var(--shiki-token-text);"> </span><span style="color:var(--shiki-token-string);">echo</span><span style="color:var(--shiki-token-text);"> </span><span style="color:var(--shiki-token-string);">hello</span></span>
<span class="line"><span style="color:var(--shiki-token-function);">@四季醬</span><span style="color:var(--shiki-token-text);"> </span><span style="color:var(--shiki-token-string);">echo</span><span style="color:var(--shiki-token-text);"> </span><span style="color:var(--shiki-token-string);">hello</span></span>
<span class="line"><span style="color:var(--shiki-token-function);">/echo</span><span style="color:var(--shiki-token-text);"> </span><span style="color:var(--shiki-token-string);">hello</span></span></code></pre></div><p>換句話說，一個指令能夠被觸發的實際條件為：</p><ul><li>訊息以 <code>prefix</code> 開頭，後面緊跟著指令呼叫</li><li>訊息以 <code>nickname</code> 開頭，後面可以有逗號或空白字元，再後面是指令呼叫</li><li>訊息以 @機器人 開頭 (可以有多個 <code>@</code>，但至少一個是機器人賬號)，後面是指令呼叫</li></ul><p>對於人數較多或是含有不止一個機器人的群聊，我們強烈建議每一個機器人都配置不同的觸發字首。而在私聊環境下，由於不用擔心誤觸，因此並沒有上面的限制。沒有觸發字首的指令呼叫也能被正常執行。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>關於 <code>prefix</code> 的幾點提示：</strong></p><ol><li><code>prefix</code> 是一個列表，預設值為 <code>[&#39;&#39;]</code> 表示無需字首也能觸發；將列表清空會導致所有指令都無法透過 <code>prefix</code> 觸發 (但仍然可以透過私聊或 <code>nickname</code> 或 @機器人 觸發)</li><li>如果你在 <code>prefix</code> 中設定了多個值，例如 <code>[&#39;.&#39;, &#39;/&#39;, &#39;&#39;]</code>，那麼 <code>.</code>, <code>/</code> 或無字首都能觸發指令；但由於 Koishi 是按順序匹配各個字首的，因此空串 <code>&#39;&#39;</code> 必須寫在最後一個</li><li>可以为不同的会话设置不同的 <code>prefix</code>，具体请参考 <a href="./customize.html#过滤器">过滤器</a> 一节</li></ol></div><h2 id="子指令" tabindex="-1">子指令 <a class="header-anchor" href="#子指令" aria-label="Permalink to &quot;子指令&quot;">​</a></h2><p><a href="./../../plugins/common/admin.html">admin</a> 外掛提供了名為 user 的指令，現在讓我們呼叫一下：</p>`,10),O=e("p",null,"指令：user",-1),H=e("p",null,"使用者管理",-1),J=e("p",null,"可用的子指令有：",-1),L=e("p",{class:"indent-1"},"authorize 許可權管理",-1),U=e("p",{class:"indent-1"},"user.locale 語言偏好",-1),F=s("<p>這裡出現了一個新的概念：子指令。子指令在呼叫上與普通的指令並沒有區別，但它們將不會顯示在 <code>help</code> 返回的全域性指令列表中，而只會顯示在父指令 <code>user</code> 的幫助資訊中。這樣設計的目的是為了避免指令列表過於冗長，同時也將指令以一種更清晰的方式進行了組織。</p><p>在上面的例子中，我們還能發現 Koishi 存在兩種不同的子指令：一種是 <strong>層級式</strong>，例如 <code>authorize</code>；而另一種則是 <strong>派生式</strong>，例如 <code>user.locale</code>。後者跟前者的區別是，它的名稱帶有父指令的名稱，以及一個小數點 <code>.</code>。在呼叫時，我們也需要加上這個小數點：</p>",2),M=e("p",null,[t("如果父指令本身沒有功能，那麼 "),e("code",null,"user"),t(" 和 "),e("code",null,"user -h"),t(" 的效果是一樣的。此時，我們也可以使用空格代替小數點進行派生式子指令的呼叫：")],-1),Q=s('<p>熟悉 Git 的使用者可能會發現，這種設計正是借鑑了 Git 的二級指令：當一個指令的功能過於複雜時，我們可以將其拆分為多個子指令，從而使得指令的功能更加清晰。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>至於 user.locale 是幹什麼的，想必大家也已經猜出來了。我们留到 <a href="./customize.html#国际化">国际化</a> 一节再详细介绍。</p></div><h2 id="指令管理" tabindex="-1">指令管理 <a class="header-anchor" href="#指令管理" aria-label="Permalink to &quot;指令管理&quot;">​</a></h2><p>開啟控制檯，我們會在活動欄中找到名為「指令管理」的頁面。你可以在這裡檢視當前所有指令的列表，並對指令的行為進行設定。</p><h3 id="設定別名" tabindex="-1">設定別名 <a class="header-anchor" href="#設定別名" aria-label="Permalink to &quot;設定別名&quot;">​</a></h3><p>點進任意指令的詳情頁，首先就能看到「名稱設定」，這裡展示了指令的全部別名。每個別名都能被用來觸發指令，而第一個別名則會作為預設名稱顯示在幫助中。</p><p>你可以在這裡新增或刪除別名，也可以將任意別名設定為預設的顯示名稱。例如，在 <code>echo</code> 指令中點選「新增別名」，輸入 <code>復讀</code>，然後點選「設為預設」，這樣一來，使用者在幫助中看到的就是 <code>復讀</code> 而不是 <code>echo</code> 了。</p><h3 id="新增子指令" tabindex="-1">新增子指令 <a class="header-anchor" href="#新增子指令" aria-label="Permalink to &quot;新增子指令&quot;">​</a></h3><p>在左側欄中，你可以將任何指令 (派生式指令除外) 拖至其他指令的下方，這將使得前者成為後者的子指令。例如，我们可以将 <a href="./../../plugins/common/bind.html"><code>bind</code></a> 指令设置为 <code>user</code> 指令的子指令，因为这属于用户管理的一部分。</p><p>點選右上角的加號按鈕，我們可以建立一個新指令。這個新指令自然是沒有行為的，它的主要目的是作為其他指令的父指令，已獲得更好的展示效果。對於透過此方法建立的新指令，我們可以透過點選右上角的垃圾桶按鈕將其移除。</p><h3 id="許可權管理" tabindex="-1">許可權管理 <a class="header-anchor" href="#許可權管理" aria-label="Permalink to &quot;許可權管理&quot;">​</a></h3><p>在「名稱設定」下方還有更多的配置項，我們可以在這裡進一步配置指令對使用者的訪問許可權。例如，將 echo 指令的 <code>authority</code> 設定為 <code>2</code>，那麼將只有 2 級以上許可權的使用者才能呼叫該指令。</p><p>我們甚至還可以單獨設定每一個指令選項的許可權等級。例如，我們可以單獨給 <code>-E, --unescape</code> 選項設定 <code>authority</code> 為 3。這樣一來，只有 3 級以上許可權的使用者才能使用 <code>echo -E</code> 的功能。</p><p>关于用户权限，请参考 <a href="./customize.html#权限管理">权限管理</a> 一节。</p>',14);function X(Y,Z,ee,oe,ae,te){const n=c("chat-message"),l=c("chat-panel");return h(),d("div",null,[p,r,o(l,null,{default:a(()=>[o(n,{nickname:"Alice"},{default:a(()=>[t("help")]),_:1}),o(n,{nickname:"Koishi"},{default:a(()=>[u,m,k,f]),_:1})]),_:1}),g,o(l,null,{default:a(()=>[o(n,{nickname:"Alice"},{default:a(()=>[t("help echo")]),_:1}),o(n,{nickname:"Koishi"},{default:a(()=>[T,x,A,b,v]),_:1})]),_:1}),P,o(l,null,{default:a(()=>[o(n,{nickname:"Alice"},{default:a(()=>[t("help help")]),_:1}),o(n,{nickname:"Koishi"},{default:a(()=>[y,S,q,K,C]),_:1})]),_:1}),V,o(l,null,{default:a(()=>[o(n,{nickname:"Alice"},{default:a(()=>[t("echo")]),_:1}),o(n,{nickname:"Koishi"},{default:a(()=>[I]),_:1})]),_:1}),E,o(l,null,{default:a(()=>[o(n,{nickname:"Alice"},{default:a(()=>[t('echo <image url="https://koishi.chat/logo.png"/>')]),_:1}),o(n,{nickname:"Koishi"},{default:a(()=>[t('<image url="https://koishi.chat/logo.png"/>')]),_:1}),o(n,{nickname:"Alice"},{default:a(()=>[t('echo -E <image url="https://koishi.chat/logo.png"/>')]),_:1}),o(n,{nickname:"Koishi"},{default:a(()=>[N]),_:1})]),_:1}),z,D,o(l,null,{default:a(()=>[o(n,{nickname:"Alice"},{default:a(()=>[t('help "foo bar"')]),_:1})]),_:1}),R,o(l,null,{default:a(()=>[o(n,{nickname:"Alice"},{default:a(()=>[t("help translate")]),_:1}),o(n,{nickname:"Koishi"},{default:a(()=>[$,w,B,W,j]),_:1}),o(n,{nickname:"Alice"},{default:a(()=>[t("translate -t ja 你好，世界")]),_:1}),o(n,{nickname:"Koishi"},{default:a(()=>[t("こんにちは世界")]),_:1})]),_:1}),G,o(l,null,{default:a(()=>[o(n,{nickname:"Alice"},{default:a(()=>[t("user")]),_:1}),o(n,{nickname:"Koishi"},{default:a(()=>[O,H,J,L,U]),_:1})]),_:1}),F,o(l,null,{default:a(()=>[o(n,{nickname:"Alice"},{default:a(()=>[t("user.locale en")]),_:1}),o(n,{nickname:"Koishi"},{default:a(()=>[t("User data updated.")]),_:1})]),_:1}),M,o(l,null,{default:a(()=>[o(n,{nickname:"Alice"},{default:a(()=>[t("user locale zh ")]),_:1}),o(n,{nickname:"Koishi"},{default:a(()=>[t("使用者資料已修改。")]),_:1})]),_:1}),Q])}const se=i(_,[["render",X]]);export{le as __pageData,se as default};
